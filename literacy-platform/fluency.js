const FLUENCY_PASSAGES = [
    {
        id: 'cvc-picnic',
        title: 'CVC Picnic',
        gradeBand: 'K-2',
        lexileBand: 'Emergent',
        focus: 'CVC words',
        passage: `Sam sat on the mat. Pam sat with him. They had a big red bag.

Pam set the bag on the grass. Sam put a cup by the bag. Pam got a lid and a nap.
"Let's pack up," said Pam. Sam did a quick check. He had a jam bun. Pam had a ham sub.

Then Sam saw a cat. The cat ran up and sat. "Hi, cat," said Sam. The cat did not hiss. It just sat.
Pam had a tip. "Do not toss food," she said. "We can pick a bit for the cat."

Sam tore a small bit of ham. The cat took it and ran. Then the cat came back with a pal.
Now Sam saw two cats. Sam held his cup. "Oh!" he said. Pam just giggled.

The wind hit the bag. The bag slid a bit. Sam ran and got it. He put a rock on top.
"Good job," said Pam. "We can sit and chat."

They ate and sipped. They did not rush. Sam felt glad. Pam felt glad, too.
At last, the sun got hot. "Time to hop," said Pam. Sam shut the bag and did a quick lap to pick up trash.
They went home and felt proud of their picnic plan.`
    },
    {
        id: 'short-vowels-trip',
        title: 'Short Vowel Trip',
        gradeBand: 'K-2',
        lexileBand: 'Emergent',
        focus: 'Short vowels',
        passage: `Jen went on a trip with her class. The bus was big. The seats were soft.
Jen sat by Ben. Ben had a red pen and a map.

The bus went up a hill. It hit a bump. Jen held on and did not slip.
"We will stop soon," said the driver. Jen felt a bit of fizz in her chest. She was glad.

At the park, the class had a list. "Find a bug," said the list. "Find a rock. Find a stick."
Jen got a stick. Ben got a rock. Kim got a bug in a jar.

Then the class did a quick jog. They ran past a pond. They saw a duck.
The duck did a dip. It got wet. Jen said, "Look! The duck can swim!"

On the way back, the wind was brisk. Jen put on her hat. Ben sat and drank from his cup.
"This trip was fun," said Ben. Jen nodded. "Yes," she said. "It was the best!"`
    },
    {
        id: 'digraph-day',
        title: 'Digraph Day',
        gradeBand: 'K-2',
        lexileBand: 'Emergent',
        focus: 'Digraphs (sh, ch, th, ng)',
        passage: `"Shh," said Ms. Chen. "We will play a digraph game."

First, the class made a wish list. "I wish for a fish," said Josh.
"I wish for a shell," said Beth. "I wish for a chip," said Chip.
Ms. Chen smiled. "We can shop for words," she said.

At the word shop, the kids had to match tiles. One tile said SH. One said CH. One said TH.
Josh found SHIP. Beth found SHOP. Chip found CHIN.

Then Ms. Chen held up a thin strip of cloth. "This is thin," she said. "Th... th... thin."
The kids tried it. "Th... thin," they said. Then she held up a thick book. "Th... thick."
They giggled. "Thick!" said Josh.

Next, they listened for /ng/. Ms. Chen rang a bell. "Ring," she said. "Sing," said Beth.
Chip said, "I can bring my sling!" Ms. Chen laughed. "Nice /ng/ words!"

At the end, each kid chose one digraph and wrote a short note.
Josh wrote, "I can fish."
Beth wrote, "I can shop."
Chip wrote, "I can sing."
Ms. Chen said, "Great work. You can hear the sounds and match the letters."`
    },
    {
        id: 'magic-e-maze',
        title: 'Magic E Maze',
        gradeBand: 'K-2',
        lexileBand: 'Emergent',
        focus: 'Magic E (CVCe)',
        passage: `Lina and Miles made a maze in the sand. They used a rake to make lines.

"Pick a word," said Lina. "If you read it, you can take a step."
Miles picked a card that said CAP. He read it fast. "Cap!" he said. He took one step.

Next card: CAPE. Miles blinked. "Cape," he said. "The e is quiet, but it makes the vowel say its name."
Lina nodded. "Nice."

They kept going.
"Kit... kite."
"Pin... pine."
"Tap... tape."
"Hop... hope."

Sometimes they made a quick sketch for the word. A kite in the sky. A cone of ice cream. A rope on a pole.

At the end of the maze, Lina said, "We did it!"
Miles said, "Magic e helps me."
They took a final step and high-fived. Then they made one more card, just for fun: "Smile."`
    },
    {
        id: 'blends-camp',
        title: 'Blends at Camp',
        gradeBand: '3-5',
        lexileBand: 'Developing',
        focus: 'Initial blends',
        passage: `The class went on a camp trek to practice outdoor skills. Their guide, Mr. Brooks, gave them a simple plan: hike, stop at the stream, and build a shelter that could block wind.

Before they left, the class checked supplies. They had a map, a compass, a tarp, and string. Each group also had a small snack pack. Sam brought granola bars. Mei brought apples. Luis brought crackers.

On the trail, the path split. Mr. Brooks said, "Stop. Look. Think." The class stood still and listened. Birds chirped. Leaves rustled. A squirrel sprinted across a log.
"Which way?" asked Sam.
"Let's read the map," said Mei. They found the creek line and the little bridge symbol. Then they chose the path that curved toward it.

At the stream, the water was clear and cold. The groups practiced skipping stones, but only for a minute. "Skills first," Mr. Brooks reminded them.
Next, they planned shelters. One group tried a lean-to. Another group tried a low A-frame. Sam's group used the tarp like a slanted roof. They stretched it tight and tied knots so it would not slip.

When the wind picked up, the shelters mattered. Leaves blew past in quick bursts. Sam tested the tarp and grinned. "It holds!"
Mr. Brooks gave a thumbs-up. "Strong knots. Smart plan."

Before heading back, the class reflected. They did not just hike; they practiced planning, teamwork, and clear communication. Sam wrote in his notebook: "Blends are like teams, too. Two sounds stick together, but you can still hear each one."`
    },
    {
        id: 'digraph-mystery',
        title: 'Digraph Mystery',
        gradeBand: '3-5',
        lexileBand: 'Developing',
        focus: 'Digraphs',
        passage: `The ship drifted past the shore when the wind shifted. Captain Shaw grabbed the rail and shouted, "Watch the waves!"

The crew moved fast. One sailor checked the chart. Another sailor hauled a rope. A third sailor watched the lighthouse flash.
"We should turn," said the captain. "If we drift too far, we will miss the dock."

Then something odd happened. A small flag near the bow flapped in a strange rhythm: flap-flap, pause, flap.
"That looks like a signal," said Nia, the youngest sailor on the crew.
Captain Shaw frowned. "A signal from who?"

Nia scanned the water. She saw a shape near the rocks. At first, it looked like driftwood. Then it shifted.
"A boat," she said. "Someone is waving."

The crew threw a line. The little boat bumped gently against the ship. Inside was a wet backpack and a notebook wrapped in plastic.
Captain Shaw opened the notebook. On the first page, a message was written in neat print:
"If you find this, please help. I tried to reach the shore, but the wind pushed me back. Follow the light, then head south."

"The lighthouse," said Nia.
Captain Shaw nodded. "We were focused on the waves. We almost missed the clue."

They turned the ship toward the lighthouse and followed the flashing beam. Soon the water calmed. The dock appeared, just where the chart said it would be.
As they tied the ship in place, Captain Shaw looked at Nia. "Great thinking," he said. "You noticed the signal and solved the mystery."

Nia smiled. "Digraphs are like clues," she said. "Two letters, one sound, and you have to watch closely."`
    },
    {
        id: 'r-controlled-rescue',
        title: 'R-Controlled Rescue',
        gradeBand: '3-5',
        lexileBand: 'Developing',
        focus: 'R-controlled vowels (ar, er, ir, or, ur)',
        passage: `The day of the park clean-up began with a surprise storm. Dark clouds rolled in, and the air turned sharp and cool.

Ms. Carter pointed to the shelter by the corner of the field. "We will wait there," she said. "Safety first."

The class hurried across the grass. A gust of wind stirred leaves into a swirl. A few trash bags tipped over and skittered.
"We should secure the bags," said Jordan. "Or they will blow everywhere."

Ms. Carter nodded. "Smart," she said. "Grab the string from the cart."

Jordan tied a knot around the bags and then heard a small chirp. He turned toward the oak tree near the border of the playground.
"Did you hear that?" he asked.

Mira listened. "A bird," she said. "Maybe it fell from a nest."

They looked under the tree and found a tiny bird shivering near a dark patch of dirt. Its feathers were wet, and it could not fly.
Jordan felt his heart thump. "We should help it," he said.

Ms. Carter called the office, and the counselor arrived with a warm towel and a box. They carefully moved the bird into the box.
"You did the right thing," the counselor said. "You stayed calm and asked for support."

When the storm passed, the class returned to the work with a stronger spirit. They picked up litter near the curb, carried sticks to the bin, and sorted recycling.
At the end, Jordan wrote in his reflection: "Our class helped in a storm. We used teamwork, and we cared."`
    },
    {
        id: 'vowel-team-quest',
        title: 'Vowel Team Quest',
        gradeBand: '6-8',
        lexileBand: 'Fluent',
        focus: 'Vowel teams',
        passage: `The team found clues on the trail, taped to trees like tiny flags. Each clue had a pattern to decode: vowel teams, silent letters, and tricky prefixes.

Their guide, Ms. Reed, held up a rule card. "When you see two vowels together," she said, "try a vowel team sound first. If it does not work, try another strategy."

The first clue read: "Follow the trail until you reach the creek." Kai circled the vowel team in "creek."
"That's /ee/," he said. "Like in tree."

The second clue read: "Look for a sign near the road." Amina pointed to "road."
"That's /oa/," she said. "Like boat."

The trail grew steeper. The team stayed close and read each sign out loud, taking turns so everyone practiced. When someone got stuck, they did not rush ahead. They paused, broke the word into parts, and tried again.

At the ridge, the last clue waited under a flat stone: "You are near the clearing."
"Near has /ear/," said Kai.
"Clearing has /air/," said Amina. "Two vowel teams in one clue."

They followed the final path and reached a green clearing that looked like a secret room in the forest. Someone had hung a small banner between two branches: "Great reading, team."

Ms. Reed smiled. "Notice what you did," she said. "You used patterns, you listened, and you supported each other. That is how strong readers work: together, with strategies."

The team cheered, but the best part was quieter: the moment when a hard word became clear because everyone stayed patient.`
    },
    {
        id: 'kindness-council',
        title: 'Kindness Council',
        gradeBand: '6-8',
        lexileBand: 'Fluent',
        focus: 'Prosody and punctuation',
        passage: `On Monday, the teacher wrote two words on the board: "KIND" and "CLEAR."
Then she asked the class to form a circle.

"Today we will practice communication," she said. "Not just what we say, but how we say it."

The class read a short script with dialogue. There were questions, exclamations, and pauses.
"Are you okay?" asked one student.
"I thought you were ignoring me!" said another.
"I was nervous," the first student replied. "I needed a minute."

When they finished, the teacher asked, "What did you notice?"
One student said, "The punctuation helped. The question mark changed my voice."
Another student said, "The pause after a period made it easier to understand."

Next, the class tried again. This time, they focused on three targets:
1) Pause at punctuation.
2) Change intonation for questions.
3) Use a calm pace, even when the text feels emotional.

After two rounds, the circle felt different. Students listened more closely. They waited before reacting. They asked better questions.

At the end, the teacher said, "Reading and speaking are connected. When we read with prosody, we practice empathy: we try to understand how someone feels and why."
The class wrote a one-sentence reflection. Many students chose the same word: "respect."`
    },
    {
        id: 'multi-syllable',
        title: 'Multi-Syllable Mission',
        gradeBand: '9-12',
        lexileBand: 'Advanced',
        focus: 'Multi-syllable decoding',
        passage: `The community center organized a volunteer project to renovate the reading lounge. The plan sounded simple: paint, sort books, set up new signage. In practice, the work required coordination.

Students collaborated in small teams. One team inventoried supplies and created a checklist. Another team reorganized the shelves by genre and reading level. A third team designed informative posters for visitors, including a short description of each section.

During the project, a teacher paused the group for a quick mini-lesson on vocabulary and decoding. "In high school," she said, "we still use the same core skills. When you meet a long word, do not guess. Break it into parts."

She wrote examples on the whiteboard:
re-organ-ize, in-form-a-tive, col-lab-o-rate, com-mu-ni-ty.
"Look for prefixes, roots, and suffixes," she added. "Then connect meaning."

The students tried it. A sign-design team debated the best word for their poster:
Should it say "accessible," "welcoming," or "inclusive"?
They discussed nuance and tone, not just spelling.

By the end of the day, the lounge looked different. The shelves were clear. The labels made sense. The posters invited people to explore.
One student stepped back and said, "This feels like more than painting. It feels like we built a system."

That sentence captured the purpose of the project: strong literacy tools help people organize ideas, communicate clearly, and make spaces more usable for everyone.`
    },
    {
        id: 'science-brief',
        title: 'Science Briefing',
        gradeBand: '9-12',
        lexileBand: 'Advanced',
        focus: 'Academic vocabulary',
        passage: `During the briefing, the researcher explained how the experiment measured temperature changes in a closed container. The class was not expected to memorize every detail. Instead, they were asked to track the logic: question, method, data, conclusion.

First, the researcher defined the variables. The independent variable was the amount of light. The dependent variable was the temperature change over time.
Next, she described the procedure. Each trial used the same container, the same starting temperature, and the same time window. Only the light level changed.

Then the data appeared on the screen as a clean graph. The line rose quickly, leveled off, and rose again when the light increased.
"What pattern do you notice?" the researcher asked.

Students offered ideas. One student pointed out the plateau, and another explained that the system reached a temporary balance.
The researcher nodded. "Good. You are interpreting, not guessing."

After the discussion, the teacher assigned a short response: summarize the results in one paragraph, then explain one limitation of the experiment.
To support students, the teacher provided a sentence frame:
"The data suggest that ______ because ______."

The point of the task was bigger than science content. It was practice in academic literacy: using precise vocabulary, following reasoning, and writing clearly about evidence.`
    }
];

const DIBELS_MCLASS_REFERENCE = {
    1: {
        BOY: {
            lnf: 42,
            psf: 31,
            nwfSounds: 30,
            nwfWords: 5,
            wrf: 12,
            orfWcpm: 10,
            orfAccuracy: 67
        },
        MOY: {
            lnf: 57,
            psf: 43,
            nwfSounds: 52,
            nwfWords: 14,
            wrf: 17,
            orfWcpm: 21,
            orfAccuracy: 87
        },
        EOY: {
            lnf: 59,
            psf: 45,
            nwfSounds: 55,
            nwfWords: 15,
            wrf: 25,
            orfWcpm: 39,
            orfAccuracy: 91
        }
    }
};

const BENCHMARK_SELECTION_KEY = 'fluency_benchmark_v1';

const gradeSelect = document.getElementById('fluency-grade');
const lexileSelect = document.getElementById('fluency-lexile');
const passageSelect = document.getElementById('fluency-select');
const passageEl = document.getElementById('fluency-passage');
const titleEl = document.getElementById('fluency-title');
const metaEl = document.getElementById('fluency-meta');
const timerDisplay = document.getElementById('fluency-timer-display');
const timerSelect = document.getElementById('fluency-minutes');
const startBtn = document.getElementById('fluency-start');
const pauseBtn = document.getElementById('fluency-pause');
const resetBtn = document.getElementById('fluency-reset');
const wordsInput = document.getElementById('fluency-words');
const errorsInput = document.getElementById('fluency-errors');
const goalInput = document.getElementById('fluency-goal');
const scoreOutput = document.getElementById('fluency-score');
const accuracyOutput = document.getElementById('fluency-accuracy');
const benchmarkResultOutput = document.getElementById('fluency-benchmark-result');
const feedbackEl = document.getElementById('fluency-feedback');
const coinsEl = document.getElementById('fluency-coins');
const streakEl = document.getElementById('fluency-streak');
const scoreBtn = document.getElementById('fluency-check');
const coachTargetSelect = document.getElementById('fluency-coach-target');
const coachStartBtn = document.getElementById('fluency-coach-start');
const coachStopBtn = document.getElementById('fluency-coach-stop');
const coachClearBtn = document.getElementById('fluency-coach-clear');
const coachStatusEl = document.getElementById('fluency-coach-status');
const coachHeardEl = document.getElementById('fluency-coach-heard');
const coachMismatchEl = document.getElementById('fluency-coach-mismatch');
const coachWaveCanvas = document.getElementById('fluency-wave-canvas');
const soundFilterInput = document.getElementById('fluency-sound-filter');
const soundRefreshBtn = document.getElementById('fluency-sound-refresh');
const soundClipsListEl = document.getElementById('fluency-sound-clips-list');
const benchmarkGradeSelect = document.getElementById('fluency-benchmark-grade');
const benchmarkWindowSelect = document.getElementById('fluency-benchmark-window');
const benchmarkUseGoalBtn = document.getElementById('fluency-use-benchmark-goal');
const benchmarkSummaryEl = document.getElementById('fluency-benchmark-summary');
const benchmarkLnfEl = document.getElementById('bench-lnf');
const benchmarkPsfEl = document.getElementById('bench-psf');
const benchmarkNwfSoundsEl = document.getElementById('bench-nwf-sounds');
const benchmarkNwfWordsEl = document.getElementById('bench-nwf-words');
const benchmarkWrfEl = document.getElementById('bench-wrf');
const benchmarkOrfEl = document.getElementById('bench-orf');
const benchmarkAccuracyEl = document.getElementById('bench-accuracy');

function applyLightTheme() {
    document.body.classList.add('force-light');
    document.documentElement.classList.add('force-light');
    document.documentElement.style.colorScheme = 'light';
}

const STATE_KEY = 'fluency_progress';
const FILTER_KEY = 'fluency_filters_v1';
let progress = { coins: 0, streak: 0 };
let timerId = null;
let remainingSeconds = 60;
let currentDuration = 60;
let currentPassage = null;

let trackerTokens = [];
let trackerStopIndex = null; // 1-based index of last word read
let trackerErrors = new Set(); // 1-based indices
let trackerMode = 'errors'; // 'errors' | 'stop'
let lineFocusEnabled = false;
let trackerActiveLine = 1;
let trackerLineCount = 1;
const REPORT_MEDIA_DB = {
    name: 'decode_report_media_v1',
    version: 1,
    store: 'clips'
};
let coachRecognition = null;
let coachListening = false;
let coachFinalTranscript = '';
let coachInterimTranscript = '';
let coachExpectedTokens = [];
let coachAudioStream = null;
let coachAudioContext = null;
let coachAnalyser = null;
let coachWaveAnimation = 0;
let coachEnergyTrail = [];
let coachGuideTrail = [];
let soundClipObjectUrls = [];
let coachLastComparison = null;

function normalizeTokenForCount(token) {
    if (!token) return '';
    return token.toString().replace(/^[^A-Za-z0-9]+|[^A-Za-z0-9]+$/g, '');
}

function tokenizePassage(text) {
    return (text || '')
        .toString()
        .replace(/\s+/g, ' ')
        .trim()
        .split(' ')
        .filter(Boolean);
}

function readLineFocusPreference() {
    try {
        const settings = window.DECODE_PLATFORM?.getSettings?.();
        if (settings && Object.prototype.hasOwnProperty.call(settings, 'lineFocus')) {
            return !!settings.lineFocus;
        }
    } catch (e) {}
    return false;
}

function writeLineFocusPreference(enabled) {
    try {
        window.DECODE_PLATFORM?.setSettings?.({ lineFocus: !!enabled }, { resize: false });
    } catch (e) {}
}

function mapWordLines() {
    const words = passageEl ? Array.from(passageEl.querySelectorAll('.fluency-word')) : [];
    if (!words.length) {
        trackerLineCount = 1;
        trackerActiveLine = 1;
        return;
    }

    let lineNumber = 0;
    let lastTop = null;
    words.forEach((wordEl) => {
        const top = Math.round(wordEl.getBoundingClientRect().top);
        if (lastTop === null || Math.abs(top - lastTop) > 8) {
            lineNumber += 1;
            lastTop = top;
        }
        wordEl.dataset.line = String(lineNumber);
    });

    trackerLineCount = Math.max(1, lineNumber);
    trackerActiveLine = Math.max(1, Math.min(trackerLineCount, trackerActiveLine));
}

function applyLineFocusHighlighting() {
    const words = passageEl ? Array.from(passageEl.querySelectorAll('.fluency-word')) : [];
    words.forEach((wordEl) => {
        wordEl.classList.remove('line-active', 'line-dim');
        if (!lineFocusEnabled) return;
        const line = Number(wordEl.dataset.line || 0);
        if (line === trackerActiveLine) {
            wordEl.classList.add('line-active');
        } else {
            wordEl.classList.add('line-dim');
        }
    });
    updateLineFocusControls();
}

function updateLineFocusControls() {
    const toggle = document.getElementById('fluency-line-focus-toggle');
    const prevBtn = document.getElementById('fluency-line-prev');
    const nextBtn = document.getElementById('fluency-line-next');
    const label = document.getElementById('fluency-line-focus-label');

    if (toggle) toggle.checked = !!lineFocusEnabled;
    if (prevBtn) prevBtn.disabled = !lineFocusEnabled || trackerActiveLine <= 1;
    if (nextBtn) nextBtn.disabled = !lineFocusEnabled || trackerActiveLine >= trackerLineCount;
    if (label) label.textContent = lineFocusEnabled ? `Line ${trackerActiveLine} / ${trackerLineCount}` : 'Line focus off';
}

function moveLineFocus(step) {
    if (!lineFocusEnabled) return;
    trackerActiveLine = Math.max(1, Math.min(trackerLineCount, trackerActiveLine + step));
    applyLineFocusHighlighting();
}

function safeParse(json) {
    try {
        return JSON.parse(json);
    } catch {
        return null;
    }
}

function escapeHtml(value) {
    return String(value || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function normalizeCoachToken(token) {
    return normalizeTokenForCount(token)
        .toLowerCase()
        .replace(/[^a-z0-9'-]/g, '');
}

function tokenizeCoachText(text) {
    return String(text || '')
        .split(/\s+/)
        .map((part) => normalizeCoachToken(part))
        .filter(Boolean);
}

function setCoachStatus(message, isError = false) {
    if (!coachStatusEl) return;
    coachStatusEl.textContent = message || '';
    coachStatusEl.classList.toggle('error', !!isError);
    coachStatusEl.classList.toggle('success', !isError && !!message);
}

function clearCoachWordHighlights() {
    passageEl?.querySelectorAll('.fluency-word').forEach((wordEl) => {
        wordEl.classList.remove('coach-match', 'coach-mismatch');
    });
}

function getCoachTargetText() {
    const source = String(currentPassage?.passage || '');
    if (!source) return '';
    const mode = String(coachTargetSelect?.value || 'sentence');
    if (mode === 'passage') return source;
    const sentenceMatch = source.match(/[^.!?]+[.!?]/);
    return (sentenceMatch?.[0] || source).trim();
}

function getCoachExpectedTokens() {
    return tokenizeCoachText(getCoachTargetText());
}

function getCoachTranscriptText() {
    return `${coachFinalTranscript} ${coachInterimTranscript}`.trim().replace(/\s+/g, ' ');
}

function updateCoachTranscriptView() {
    if (!coachHeardEl) return;
    const text = getCoachTranscriptText();
    coachHeardEl.textContent = text || 'Start listening, then read aloud.';
    coachHeardEl.classList.toggle('muted', !text);
}

function buildLetterCue(expectedWord, heardWord) {
    const expected = String(expectedWord || '');
    const heard = String(heardWord || '');
    if (!expected || !heard) return '';
    const maxLen = Math.max(expected.length, heard.length);
    let mismatchAt = -1;
    for (let index = 0; index < maxLen; index += 1) {
        if ((expected[index] || '') !== (heard[index] || '')) {
            mismatchAt = index + 1;
            break;
        }
    }
    if (mismatchAt <= 0) return '';
    return `first letter shift at position ${mismatchAt}`;
}

function describeSoundCue(expectedWord = '', heardWord = '') {
    const expected = String(expectedWord || '').toLowerCase();
    const heard = String(heardWord || '').toLowerCase();
    if (!expected) return '';

    const cueRules = [
        { pattern: /th/, cue: 'Track /th/: tongue between teeth, then release with voice.' },
        { pattern: /sh/, cue: 'Track /sh/: lips forward and airflow steady.' },
        { pattern: /ch/, cue: 'Track /ch/: start with /t/ then release to /sh/.' },
        { pattern: /ph/, cue: 'Track /f/: lower lip touches upper teeth.' },
        { pattern: /(ar|er|ir|or|ur)/, cue: 'Track the r-controlled vowel chunk before finishing the word.' },
        { pattern: /(ea|ee|ai|ay|oa|ow|igh)/, cue: 'Hold the vowel team as one sound before moving to the ending.' },
        { pattern: /(tion|sion)/, cue: 'Blend the ending as /shun/ while keeping the root clear.' }
    ];
    const matched = cueRules.find((rule) => rule.pattern.test(expected));
    if (matched) return matched.cue;
    if (heard && expected[0] !== heard[0]) return 'Restart with the first sound, then connect the vowel smoothly.';
    return 'Tap each sound left-to-right, then blend once at normal pace.';
}

function buildProsodyTips(targetText = '') {
    const text = String(targetText || '');
    const tips = [];
    if (/[?]/.test(text)) tips.push('Lift intonation slightly at each question mark.');
    if (/[,;]/.test(text)) tips.push('Use a short pause at commas and semicolons.');
    if (/[.!]/.test(text)) tips.push('Use a full stop pause at sentence endings.');
    if (/["“”]/.test(text)) tips.push('Shift expression for dialogue so character voice is clear.');
    if (!tips.length) tips.push('Keep a steady pace and finish each phrase before starting the next.');
    return tips.slice(0, 3);
}

function summarizeMismatchCounts(mismatches = []) {
    return mismatches.reduce((acc, row) => {
        const type = String(row?.type || '');
        if (type === 'missing') acc.missing += 1;
        else if (type === 'extra') acc.extra += 1;
        else acc.substitution += 1;
        return acc;
    }, { missing: 0, extra: 0, substitution: 0 });
}

function buildFocusWords(mismatches = []) {
    const seen = new Set();
    const focus = [];
    mismatches.forEach((row) => {
        if (focus.length >= 4) return;
        const expected = normalizeCoachToken(row?.expected || '');
        const heard = normalizeCoachToken(row?.heard || '');
        const token = expected || heard;
        if (!token || seen.has(token)) return;
        seen.add(token);
        focus.push({
            token,
            cue: describeSoundCue(expected, heard)
        });
    });
    return focus;
}

function compareCoachTokens(expectedTokens, heardTokens) {
    const mismatches = [];
    const matches = [];
    let expectedIndex = 0;
    let heardIndex = 0;

    while (expectedIndex < expectedTokens.length && heardIndex < heardTokens.length) {
        const expected = expectedTokens[expectedIndex];
        const heard = heardTokens[heardIndex];
        if (expected === heard) {
            matches.push({ expectedIndex: expectedIndex + 1, token: expected });
            expectedIndex += 1;
            heardIndex += 1;
            continue;
        }

        const heardNext = heardTokens[heardIndex + 1];
        if (heardNext && heardNext === expected) {
            mismatches.push({
                type: 'extra',
                expectedIndex: expectedIndex + 1,
                expected,
                heard
            });
            heardIndex += 1;
            continue;
        }

        const expectedNext = expectedTokens[expectedIndex + 1];
        if (expectedNext && expectedNext === heard) {
            mismatches.push({
                type: 'missing',
                expectedIndex: expectedIndex + 1,
                expected,
                heard
            });
            expectedIndex += 1;
            continue;
        }

        mismatches.push({
            type: 'substitution',
            expectedIndex: expectedIndex + 1,
            expected,
            heard,
            cue: buildLetterCue(expected, heard)
        });
        expectedIndex += 1;
        heardIndex += 1;
    }

    while (expectedIndex < expectedTokens.length) {
        mismatches.push({
            type: 'missing',
            expectedIndex: expectedIndex + 1,
            expected: expectedTokens[expectedIndex],
            heard: ''
        });
        expectedIndex += 1;
    }

    while (heardIndex < heardTokens.length) {
        mismatches.push({
            type: 'extra',
            expectedIndex: expectedTokens.length,
            expected: '',
            heard: heardTokens[heardIndex]
        });
        heardIndex += 1;
    }

    return { mismatches, matches };
}

function highlightCoachMismatches(result) {
    clearCoachWordHighlights();
    const mismatchSet = new Set(
        (result?.mismatches || [])
            .filter((row) => row.type !== 'extra' && row.expectedIndex > 0)
            .map((row) => Number(row.expectedIndex))
    );
    const matchSet = new Set(
        (result?.matches || [])
            .map((row) => Number(row.expectedIndex))
            .filter((index) => !mismatchSet.has(index))
    );

    let expectedIndex = 0;
    passageEl?.querySelectorAll('.fluency-word').forEach((wordEl) => {
        const normalized = normalizeCoachToken(wordEl.textContent || '');
        if (!normalized) return;
        expectedIndex += 1;
        if (mismatchSet.has(expectedIndex)) {
            wordEl.classList.add('coach-mismatch');
            return;
        }
        if (matchSet.has(expectedIndex)) {
            wordEl.classList.add('coach-match');
        }
    });
}

function renderCoachMismatchReport(result, expectedTokens, heardTokens) {
    if (!coachMismatchEl) return;
    if (!heardTokens.length) {
        coachMismatchEl.textContent = 'Mismatches will appear here with targeted letter cues.';
        coachMismatchEl.classList.add('muted');
        return;
    }

    const mismatches = Array.isArray(result?.mismatches) ? result.mismatches : [];
    if (!mismatches.length) {
        const prosodyTips = buildProsodyTips(getCoachTargetText());
        coachMismatchEl.innerHTML = `
            <div class="fluency-coach-good">Strong match. Keep that pacing and expression.</div>
            <div class="fluency-coach-prosody"><strong>Prosody target:</strong> ${escapeHtml(prosodyTips.join(' '))}</div>
        `;
        coachMismatchEl.classList.remove('muted');
        return;
    }

    const rows = mismatches.slice(0, 6).map((row) => {
        if (row.type === 'missing') {
            return `<li>Missed <strong>${escapeHtml(row.expected)}</strong> near word ${row.expectedIndex}. <span class="fluency-coach-cue">${escapeHtml(describeSoundCue(row.expected, row.heard))}</span></li>`;
        }
        if (row.type === 'extra') {
            return `<li>Extra word heard: <strong>${escapeHtml(row.heard)}</strong>.</li>`;
        }
        const cue = row.cue ? ` (${escapeHtml(row.cue)})` : '';
        const soundCue = describeSoundCue(row.expected, row.heard);
        return `<li>Expected <strong>${escapeHtml(row.expected)}</strong>, heard <strong>${escapeHtml(row.heard)}</strong>${cue}. <span class="fluency-coach-cue">${escapeHtml(soundCue)}</span></li>`;
    }).join('');

    const precision = expectedTokens.length
        ? Math.max(0, ((expectedTokens.length - mismatches.length) / expectedTokens.length) * 100)
        : 0;
    const counts = summarizeMismatchCounts(mismatches);
    const focusWords = buildFocusWords(mismatches);
    const focusWordLine = focusWords.length
        ? focusWords.map((item) => `${item.token} (${item.cue})`).join(' · ')
        : 'Replay the first sentence and track first sound + vowel in each target word.';
    const prosodyTips = buildProsodyTips(getCoachTargetText());
    coachMismatchEl.innerHTML = `
        <div class="fluency-coach-score">Approximate match: ${precision.toFixed(0)}%</div>
        <div class="fluency-coach-breakdown">Substitutions: ${counts.substitution} · Missed: ${counts.missing} · Extra: ${counts.extra}</div>
        <ul class="fluency-coach-list">${rows}</ul>
        <div class="fluency-coach-loop"><strong>20-second practice loop:</strong> ${escapeHtml(focusWordLine)}</div>
        <div class="fluency-coach-prosody"><strong>Prosody target:</strong> ${escapeHtml(prosodyTips.join(' '))}</div>
    `;
    coachMismatchEl.classList.remove('muted');
}

function updateCoachComparison() {
    coachExpectedTokens = getCoachExpectedTokens();
    const heardTokens = tokenizeCoachText(getCoachTranscriptText());
    const result = compareCoachTokens(coachExpectedTokens, heardTokens);
    coachLastComparison = {
        expectedTokens: coachExpectedTokens.slice(),
        heardTokens: heardTokens.slice(),
        mismatches: Array.isArray(result?.mismatches) ? result.mismatches.slice() : [],
        matches: Array.isArray(result?.matches) ? result.matches.slice() : []
    };
    highlightCoachMismatches(result);
    renderCoachMismatchReport(result, coachExpectedTokens, heardTokens);
}

function buildCoachGuideTrail(text, sampleCount = 140) {
    const tokens = String(text || '').split(/\s+/).filter(Boolean);
    if (!tokens.length) {
        return Array.from({ length: sampleCount }, () => 0.22);
    }
    const tokenEnergy = tokens.map((token) => {
        const trimmed = String(token || '').trim();
        if (/[!?]$/.test(trimmed)) return 0.72;
        if (/[.,;:]$/.test(trimmed)) return 0.2;
        if (trimmed.length >= 8) return 0.52;
        return 0.36;
    });
    const trail = [];
    for (let index = 0; index < sampleCount; index += 1) {
        const pct = sampleCount <= 1 ? 0 : index / (sampleCount - 1);
        const tokenIndex = Math.min(tokenEnergy.length - 1, Math.floor(pct * tokenEnergy.length));
        trail.push(tokenEnergy[tokenIndex]);
    }
    return trail;
}

function ensureCoachCanvasSize() {
    if (!coachWaveCanvas) return;
    const ratio = window.devicePixelRatio || 1;
    const rect = coachWaveCanvas.getBoundingClientRect();
    const width = Math.max(300, Math.round(rect.width || 640));
    const height = Math.max(120, Math.round(rect.height || 150));
    const targetWidth = Math.round(width * ratio);
    const targetHeight = Math.round(height * ratio);
    if (coachWaveCanvas.width === targetWidth && coachWaveCanvas.height === targetHeight) return;
    coachWaveCanvas.width = targetWidth;
    coachWaveCanvas.height = targetHeight;
}

function drawTrailLine(ctx, trail, width, height, color) {
    if (!trail.length) return;
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    trail.forEach((value, index) => {
        const x = (index / Math.max(1, trail.length - 1)) * width;
        const y = height - (Math.max(0, Math.min(1, value)) * (height - 10)) - 5;
        if (index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();
}

function drawCoachWaveFrame() {
    if (!coachWaveCanvas) return;
    ensureCoachCanvasSize();
    const context = coachWaveCanvas.getContext('2d');
    if (!context) return;

    const ratio = window.devicePixelRatio || 1;
    const width = coachWaveCanvas.width / ratio;
    const height = coachWaveCanvas.height / ratio;
    context.setTransform(ratio, 0, 0, ratio, 0, 0);
    context.clearRect(0, 0, width, height);

    context.fillStyle = 'rgba(248, 250, 252, 0.95)';
    context.fillRect(0, 0, width, height);

    context.strokeStyle = 'rgba(148, 163, 184, 0.25)';
    context.lineWidth = 1;
    for (let row = 1; row <= 3; row += 1) {
        const y = (height / 4) * row;
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(width, y);
        context.stroke();
    }

    let energy = 0;
    if (coachAnalyser) {
        const buffer = new Float32Array(coachAnalyser.fftSize);
        coachAnalyser.getFloatTimeDomainData(buffer);
        let sum = 0;
        for (let index = 0; index < buffer.length; index += 1) {
            const sample = buffer[index];
            sum += sample * sample;
        }
        const rms = Math.sqrt(sum / Math.max(1, buffer.length));
        energy = Math.min(1, rms * 8);
    }
    coachEnergyTrail.push(energy);
    if (coachEnergyTrail.length > 140) coachEnergyTrail.shift();

    if (!coachGuideTrail.length) {
        coachGuideTrail = buildCoachGuideTrail(getCoachTargetText(), 140);
    }
    while (coachGuideTrail.length < coachEnergyTrail.length) {
        coachGuideTrail.push(coachGuideTrail[coachGuideTrail.length - 1] || 0.24);
    }

    drawTrailLine(context, coachGuideTrail.slice(-140), width, height, 'rgba(99, 102, 241, 0.55)');
    drawTrailLine(context, coachEnergyTrail.slice(-140), width, height, 'rgba(14, 165, 233, 0.95)');
}

function stopCoachWaveLoop() {
    if (coachWaveAnimation) {
        cancelAnimationFrame(coachWaveAnimation);
        coachWaveAnimation = 0;
    }
}

function startCoachWaveLoop() {
    stopCoachWaveLoop();
    const tick = () => {
        drawCoachWaveFrame();
        if (coachListening) {
            coachWaveAnimation = requestAnimationFrame(tick);
        } else {
            coachWaveAnimation = 0;
            drawCoachWaveFrame();
        }
    };
    coachWaveAnimation = requestAnimationFrame(tick);
}

async function startCoachAudioCapture() {
    if (coachAudioStream && coachAnalyser) return true;
    if (!navigator.mediaDevices?.getUserMedia) return false;
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtx) {
        stream.getTracks().forEach((track) => track.stop());
        return false;
    }
    const audioContext = new AudioCtx();
    const source = audioContext.createMediaStreamSource(stream);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 1024;
    source.connect(analyser);
    coachAudioStream = stream;
    coachAudioContext = audioContext;
    coachAnalyser = analyser;
    return true;
}

function stopCoachAudioCapture() {
    try {
        coachAudioStream?.getTracks?.().forEach((track) => track.stop());
    } catch (e) {}
    coachAudioStream = null;
    coachAnalyser = null;
    if (coachAudioContext && typeof coachAudioContext.close === 'function') {
        coachAudioContext.close().catch(() => {});
    }
    coachAudioContext = null;
}

function updateCoachButtons() {
    if (coachStartBtn) coachStartBtn.disabled = coachListening;
    if (coachStopBtn) coachStopBtn.disabled = !coachListening;
}

function getSpeechRecognitionCtor() {
    return window.SpeechRecognition || window.webkitSpeechRecognition || null;
}

function ensureCoachRecognition() {
    if (coachRecognition) return coachRecognition;
    const Ctor = getSpeechRecognitionCtor();
    if (!Ctor) return null;
    const recognition = new Ctor();
    recognition.lang = 'en-US';
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.maxAlternatives = 1;
    recognition.onresult = (event) => {
        let interim = '';
        for (let index = event.resultIndex; index < event.results.length; index += 1) {
            const transcript = String(event.results[index]?.[0]?.transcript || '').trim();
            if (!transcript) continue;
            if (event.results[index].isFinal) {
                coachFinalTranscript = `${coachFinalTranscript} ${transcript}`.trim();
            } else {
                interim = `${interim} ${transcript}`.trim();
            }
        }
        coachInterimTranscript = interim;
        updateCoachTranscriptView();
        updateCoachComparison();
    };
    recognition.onerror = (event) => {
        setCoachStatus(`Read coach error: ${String(event?.error || 'unknown')}.`, true);
    };
    recognition.onend = () => {
        if (!coachListening) return;
        coachListening = false;
        updateCoachButtons();
        stopCoachAudioCapture();
        stopCoachWaveLoop();
        setCoachStatus('Listening ended. Tap Start listening to continue.');
    };
    coachRecognition = recognition;
    return recognition;
}

async function startCoachListening() {
    if (coachListening) return;
    coachExpectedTokens = getCoachExpectedTokens();
    coachGuideTrail = buildCoachGuideTrail(getCoachTargetText(), 140);
    if (!coachExpectedTokens.length) {
        setCoachStatus('No target text available for read coach.', true);
        return;
    }

    setCoachStatus('Starting microphone and read coach...');
    try {
        await startCoachAudioCapture();
    } catch (error) {
        setCoachStatus('Microphone access blocked. Allow microphone and try again.', true);
        return;
    }

    coachListening = true;
    updateCoachButtons();
    startCoachWaveLoop();

    const recognition = ensureCoachRecognition();
    if (!recognition) {
        setCoachStatus('Speech-to-text unavailable in this browser. Wave coach still active.', true);
        return;
    }
    try {
        recognition.start();
        setCoachStatus('Listening... read naturally and keep your pacing smooth.');
    } catch (error) {
        coachListening = false;
        updateCoachButtons();
        stopCoachAudioCapture();
        stopCoachWaveLoop();
        setCoachStatus('Could not start speech recognition. Try again.', true);
    }
}

function stopCoachListening() {
    if (!coachListening && !coachRecognition) return;
    coachListening = false;
    updateCoachButtons();
    try {
        coachRecognition?.stop?.();
    } catch (error) {}
    stopCoachAudioCapture();
    stopCoachWaveLoop();
    setCoachStatus('Listening stopped.');
}

function clearCoach() {
    stopCoachListening();
    coachFinalTranscript = '';
    coachInterimTranscript = '';
    coachLastComparison = null;
    coachEnergyTrail = [];
    coachGuideTrail = buildCoachGuideTrail(getCoachTargetText(), 140);
    updateCoachTranscriptView();
    updateCoachComparison();
    drawCoachWaveFrame();
    setCoachStatus('Read coach cleared.');
}

async function readTeacherSoundClips() {
    if (!window.indexedDB) return [];
    return new Promise((resolve) => {
        const request = indexedDB.open(REPORT_MEDIA_DB.name, REPORT_MEDIA_DB.version);
        request.onerror = () => resolve([]);
        request.onupgradeneeded = () => {};
        request.onsuccess = () => {
            const db = request.result;
            try {
                const tx = db.transaction(REPORT_MEDIA_DB.store, 'readonly');
                const store = tx.objectStore(REPORT_MEDIA_DB.store);
                const getAll = store.getAll();
                getAll.onerror = () => {
                    db.close();
                    resolve([]);
                };
                getAll.onsuccess = () => {
                    const rows = Array.isArray(getAll.result) ? getAll.result : [];
                    db.close();
                    resolve(rows);
                };
            } catch (error) {
                db.close();
                resolve([]);
            }
        };
    });
}

function releaseSoundClipUrls() {
    soundClipObjectUrls.forEach((url) => {
        try {
            URL.revokeObjectURL(url);
        } catch (error) {}
    });
    soundClipObjectUrls = [];
}

async function refreshSoundClips() {
    if (!soundClipsListEl) return;
    const query = String(soundFilterInput?.value || '').trim().toLowerCase();
    soundClipsListEl.innerHTML = '<div class="muted">Loading clips...</div>';
    const rows = await readTeacherSoundClips();
    releaseSoundClipUrls();

    const filtered = rows
        .filter((clip) => String(clip?.owner || '').toLowerCase() === 'teacher')
        .filter((clip) => {
            if (!query) return true;
            const label = String(clip?.label || '').toLowerCase();
            const tags = Array.isArray(clip?.tags) ? clip.tags.map((item) => String(item || '').toLowerCase()) : [];
            return label.includes(query) || tags.some((tag) => tag.includes(query));
        })
        .sort((a, b) => Number(b?.createdAt || 0) - Number(a?.createdAt || 0))
        .slice(0, 12);

    if (!filtered.length) {
        soundClipsListEl.innerHTML = '<div class="muted">No matching teacher clips yet. Record clips in Teacher Report and tag them by sound.</div>';
        return;
    }

    const cards = filtered.map((clip) => {
        const objectUrl = URL.createObjectURL(clip.blob);
        soundClipObjectUrls.push(objectUrl);
        const tags = Array.isArray(clip.tags) ? clip.tags : [];
        const media = clip.sourceType === 'audio'
            ? `<audio controls preload="none" src="${objectUrl}"></audio>`
            : `<video controls preload="metadata" src="${objectUrl}" playsinline></video>`;
        const tagsLine = tags.length
            ? `<div class="fluency-sound-clip-tags">${tags.map((tag) => `<span class="fluency-sound-clip-tag">#${escapeHtml(tag)}</span>`).join('')}</div>`
            : '';
        return `
            <article class="fluency-sound-clip-card">
                <div class="fluency-sound-clip-head">
                    <div class="fluency-sound-clip-title">${escapeHtml(clip.label || 'Teacher clip')}</div>
                    <div class="fluency-sound-clip-date">${escapeHtml(new Date(Number(clip.createdAt || Date.now())).toLocaleDateString())}</div>
                </div>
                ${tagsLine}
                <div class="fluency-sound-clip-media">${media}</div>
            </article>
        `;
    }).join('');

    soundClipsListEl.innerHTML = cards;
}

function getDefaultGradeBand() {
    try {
        const profile = window.DECODE_PLATFORM?.getProfile?.();
        return profile?.gradeBand || '';
    } catch (e) {
        return '';
    }
}

function ensureTrackerUI() {
    const panel = passageEl?.closest('.fluency-panel');
    if (!panel) return;
    if (document.getElementById('fluency-tracker')) return;

    const tracker = document.createElement('div');
    tracker.id = 'fluency-tracker';
    tracker.className = 'fluency-tracker';
    tracker.innerHTML = `
        <div class="fluency-tracker-row">
            <div class="fluency-tracker-buttons">
                <button id="fluency-set-stop" class="secondary-btn" type="button">Set stop word</button>
                <button id="fluency-clear-marks" class="secondary-btn" type="button">Clear marks</button>
            </div>
            <div class="fluency-tracker-stats" aria-label="Tracker stats">
                <span>Stop: <strong id="fluency-stop-label">—</strong></span>
                <span>Errors: <strong id="fluency-error-label">0</strong></span>
                <span>Words: <strong id="fluency-wordcount-label">0</strong></span>
            </div>
        </div>
        <div class="fluency-tracker-hint">
            Click a word to mark an error. Press “Set stop word”, then click the last word read.
        </div>
        <div class="fluency-line-focus-controls">
            <label class="fluency-line-focus-toggle">
                <input id="fluency-line-focus-toggle" type="checkbox" />
                <span>Line focus</span>
            </label>
            <button id="fluency-line-prev" class="secondary-btn" type="button">Prev line</button>
            <button id="fluency-line-next" class="secondary-btn" type="button">Next line</button>
            <span id="fluency-line-focus-label" class="fluency-line-focus-label">Line focus off</span>
        </div>
    `;

    panel.querySelector('.fluency-panel-header')?.insertAdjacentElement('afterend', tracker);

    tracker.querySelector('#fluency-set-stop')?.addEventListener('click', () => {
        trackerMode = 'stop';
        feedbackEl.textContent = 'Click the last word read.';
        tracker.classList.add('stop-mode');
    });

    tracker.querySelector('#fluency-clear-marks')?.addEventListener('click', () => {
        clearTrackerMarks();
    });

    tracker.querySelector('#fluency-line-focus-toggle')?.addEventListener('change', (event) => {
        lineFocusEnabled = !!event.target?.checked;
        writeLineFocusPreference(lineFocusEnabled);
        if (lineFocusEnabled) {
            mapWordLines();
            trackerActiveLine = Math.max(1, Math.min(trackerLineCount, trackerActiveLine || 1));
        }
        applyLineFocusHighlighting();
    });

    tracker.querySelector('#fluency-line-prev')?.addEventListener('click', () => {
        moveLineFocus(-1);
    });

    tracker.querySelector('#fluency-line-next')?.addEventListener('click', () => {
        moveLineFocus(1);
    });

    updateLineFocusControls();
}

function clearTrackerMarks() {
    trackerStopIndex = null;
    trackerErrors = new Set();
    trackerMode = 'errors';
    document.getElementById('fluency-tracker')?.classList.remove('stop-mode');
    passageEl?.querySelectorAll('.fluency-word').forEach(wordEl => {
        wordEl.classList.remove('error', 'stop', 'after-stop');
    });
    trackerActiveLine = 1;
    syncTrackerToInputs();
    mapWordLines();
    applyLineFocusHighlighting();
}

function syncTrackerLabels() {
    const stopLabel = document.getElementById('fluency-stop-label');
    const errorLabel = document.getElementById('fluency-error-label');
    const wordcountLabel = document.getElementById('fluency-wordcount-label');

    const stopDisplay = trackerStopIndex ? String(trackerStopIndex) : '—';
    if (stopLabel) stopLabel.textContent = stopDisplay;

    const errorsWithinRange = Array.from(trackerErrors).filter(idx => !trackerStopIndex || idx <= trackerStopIndex);
    if (errorLabel) errorLabel.textContent = String(errorsWithinRange.length);

    const countable = trackerTokens.map(normalizeTokenForCount).filter(Boolean);
    if (wordcountLabel) wordcountLabel.textContent = String(countable.length);
}

function syncTrackerToInputs() {
    const countable = trackerTokens.map(normalizeTokenForCount).filter(Boolean);
    const wordCount = countable.length;

    const wordsRead = trackerStopIndex ? Math.min(trackerStopIndex, wordCount) : 0;
    const errors = Array.from(trackerErrors).filter(idx => idx <= (trackerStopIndex || wordCount)).length;

    if (wordsRead) {
        wordsInput.value = String(wordsRead);
    } else if (trackerStopIndex === null) {
        // Leave teacher input alone if they are typing manually.
    }

    errorsInput.value = String(errors);
    syncTrackerLabels();
}

function applyStopHighlighting() {
    passageEl?.querySelectorAll('.fluency-word').forEach(wordEl => {
        const idx = Number(wordEl.dataset.index || 0);
        wordEl.classList.toggle('after-stop', !!trackerStopIndex && idx > trackerStopIndex);
        wordEl.classList.toggle('stop', !!trackerStopIndex && idx === trackerStopIndex);
    });
    applyLineFocusHighlighting();
}

function renderTrackablePassage(text) {
    ensureTrackerUI();
    trackerTokens = tokenizePassage(text);
    trackerStopIndex = null;
    trackerErrors = new Set();
    trackerMode = 'errors';
    document.getElementById('fluency-tracker')?.classList.remove('stop-mode');

    passageEl.innerHTML = '';
    trackerTokens.forEach((token, i) => {
        const idx = i + 1;
        const span = document.createElement('span');
        span.className = 'fluency-word';
        span.dataset.index = String(idx);
        span.textContent = token;

        span.addEventListener('click', () => {
            const clickedLine = Number(span.dataset.line || 0);
            if (lineFocusEnabled && clickedLine > 0) {
                trackerActiveLine = clickedLine;
            }

            if (trackerMode === 'stop') {
                trackerStopIndex = idx;
                trackerMode = 'errors';
                document.getElementById('fluency-tracker')?.classList.remove('stop-mode');
                feedbackEl.textContent = 'Stop word set. Mark any errors (tap words).';
                applyStopHighlighting();
                syncTrackerToInputs();
                return;
            }

            if (trackerErrors.has(idx)) {
                trackerErrors.delete(idx);
                span.classList.remove('error');
            } else {
                trackerErrors.add(idx);
                span.classList.add('error');
            }
            syncTrackerToInputs();
            applyLineFocusHighlighting();
        });

        passageEl.appendChild(span);
        passageEl.appendChild(document.createTextNode(' '));
    });

    syncTrackerLabels();
    mapWordLines();
    trackerActiveLine = 1;
    applyLineFocusHighlighting();
}

function loadProgress() {
    try {
        const saved = JSON.parse(localStorage.getItem(STATE_KEY));
        if (saved) progress = { ...progress, ...saved };
    } catch (e) {}
}

function saveProgress() {
    localStorage.setItem(STATE_KEY, JSON.stringify(progress));
}

function updateHud() {
    coinsEl.textContent = progress.coins;
    streakEl.textContent = progress.streak;
}

function buildFilters() {
    const gradeBands = Array.from(new Set(FLUENCY_PASSAGES.map(p => p.gradeBand)));
    const lexileBands = Array.from(new Set(FLUENCY_PASSAGES.map(p => p.lexileBand)));
    gradeSelect.innerHTML = gradeBands.map(band => `<option value="${band}">${band}</option>`).join('');
    lexileSelect.innerHTML = ['All'].concat(lexileBands).map(band => `<option value="${band}">${band}</option>`).join('');
}

function loadFilters() {
    const parsed = safeParse(localStorage.getItem(FILTER_KEY) || '');
    if (parsed?.grade && Array.from(gradeSelect.options).some(o => o.value === parsed.grade)) {
        gradeSelect.value = parsed.grade;
    } else {
        const fallback = getDefaultGradeBand();
        if (fallback && Array.from(gradeSelect.options).some(o => o.value === fallback)) {
            gradeSelect.value = fallback;
        }
    }

    if (parsed?.lexile && Array.from(lexileSelect.options).some(o => o.value === parsed.lexile)) {
        lexileSelect.value = parsed.lexile;
    }
}

function saveFilters() {
    localStorage.setItem(FILTER_KEY, JSON.stringify({
        grade: gradeSelect.value,
        lexile: lexileSelect.value
    }));
}

function getDefaultBenchmarkWindow() {
    const month = new Date().getMonth() + 1;
    if (month >= 8 && month <= 11) return 'BOY';
    if (month >= 12 || month <= 3) return 'MOY';
    return 'EOY';
}

function getBenchmarkGradeOptions() {
    return Object.keys(DIBELS_MCLASS_REFERENCE)
        .map((key) => Number(key))
        .filter((value) => Number.isFinite(value))
        .sort((a, b) => a - b);
}

function buildBenchmarkControls() {
    if (!benchmarkGradeSelect) return;
    const grades = getBenchmarkGradeOptions();
    benchmarkGradeSelect.innerHTML = grades
        .map((grade) => `<option value="${grade}">Grade ${grade}</option>`)
        .join('');
}

function saveBenchmarkSelection() {
    if (!benchmarkGradeSelect || !benchmarkWindowSelect) return;
    localStorage.setItem(BENCHMARK_SELECTION_KEY, JSON.stringify({
        grade: benchmarkGradeSelect.value,
        window: benchmarkWindowSelect.value
    }));
}

function loadBenchmarkSelection() {
    if (!benchmarkGradeSelect || !benchmarkWindowSelect) return;
    const parsed = safeParse(localStorage.getItem(BENCHMARK_SELECTION_KEY) || '');
    const grades = getBenchmarkGradeOptions();
    const fallbackGrade = grades.length ? String(grades[0]) : '1';
    const parsedGrade = String(parsed?.grade || '');
    benchmarkGradeSelect.value = grades.some((grade) => String(grade) === parsedGrade)
        ? parsedGrade
        : fallbackGrade;
    const windowOptions = ['BOY', 'MOY', 'EOY'];
    benchmarkWindowSelect.value = windowOptions.includes(parsed?.window)
        ? parsed.window
        : getDefaultBenchmarkWindow();
}

function getSelectedBenchmark() {
    const grade = Number(benchmarkGradeSelect?.value || 0);
    const windowKey = String(benchmarkWindowSelect?.value || 'BOY');
    if (!Number.isFinite(grade)) return null;
    return DIBELS_MCLASS_REFERENCE[grade]?.[windowKey] || null;
}

function setBenchmarkGridValues(values = null) {
    const record = values || {};
    if (benchmarkLnfEl) benchmarkLnfEl.textContent = Number.isFinite(record.lnf) ? `${record.lnf}+` : '—';
    if (benchmarkPsfEl) benchmarkPsfEl.textContent = Number.isFinite(record.psf) ? `${record.psf}+` : '—';
    if (benchmarkNwfSoundsEl) benchmarkNwfSoundsEl.textContent = Number.isFinite(record.nwfSounds) ? `${record.nwfSounds}+` : '—';
    if (benchmarkNwfWordsEl) benchmarkNwfWordsEl.textContent = Number.isFinite(record.nwfWords) ? `${record.nwfWords}+` : '—';
    if (benchmarkWrfEl) benchmarkWrfEl.textContent = Number.isFinite(record.wrf) ? `${record.wrf}+` : '—';
    if (benchmarkOrfEl) benchmarkOrfEl.textContent = Number.isFinite(record.orfWcpm) ? `${record.orfWcpm}+` : '—';
    if (benchmarkAccuracyEl) benchmarkAccuracyEl.textContent = Number.isFinite(record.orfAccuracy) ? `${record.orfAccuracy}%+` : '—';
}

function renderBenchmarkSummary() {
    const grade = benchmarkGradeSelect?.value || '1';
    const windowKey = benchmarkWindowSelect?.value || 'BOY';
    const benchmark = getSelectedBenchmark();
    if (!benchmark) {
        if (benchmarkSummaryEl) {
            benchmarkSummaryEl.textContent = 'No benchmark loaded for this selection.';
        }
        setBenchmarkGridValues(null);
        if (benchmarkResultOutput) benchmarkResultOutput.textContent = '—';
        return;
    }

    setBenchmarkGridValues(benchmark);
    if (benchmarkSummaryEl) {
        benchmarkSummaryEl.textContent = `Reference target for Grade ${grade} ${windowKey}: ORF ${benchmark.orfWcpm}+ WCPM and ${benchmark.orfAccuracy}%+ accuracy.`;
    }
}

function applySelectedBenchmarkGoal() {
    const benchmark = getSelectedBenchmark();
    if (!benchmark || !Number.isFinite(benchmark.orfWcpm)) return;
    goalInput.value = String(benchmark.orfWcpm);
    feedbackEl.textContent = `Goal synced to Grade ${benchmarkGradeSelect.value} ${benchmarkWindowSelect.value} ORF benchmark (${benchmark.orfWcpm} WCPM).`;
}

function evaluateBenchmarkStatus(orf = 0, accuracyPct = null) {
    const benchmark = getSelectedBenchmark();
    if (!benchmark) return null;
    const meetsOrf = Number.isFinite(benchmark.orfWcpm) ? orf >= benchmark.orfWcpm : true;
    const meetsAccuracy = Number.isFinite(benchmark.orfAccuracy) && Number.isFinite(accuracyPct)
        ? accuracyPct >= benchmark.orfAccuracy
        : true;
    return {
        meets: meetsOrf && meetsAccuracy,
        meetsOrf,
        meetsAccuracy,
        benchmark
    };
}

function renderBenchmarkResult(orf = 0, accuracyPct = null) {
    if (!benchmarkResultOutput) return;
    if (!Number.isFinite(orf)) {
        benchmarkResultOutput.textContent = '—';
        benchmarkResultOutput.classList.remove('is-good', 'is-warn');
        return;
    }
    const status = evaluateBenchmarkStatus(orf, accuracyPct);
    if (!status) {
        benchmarkResultOutput.textContent = 'No benchmark selected';
        benchmarkResultOutput.classList.remove('is-good', 'is-warn');
        return;
    }

    if (status.meets) {
        benchmarkResultOutput.textContent = 'At/above benchmark';
        benchmarkResultOutput.classList.add('is-good');
        benchmarkResultOutput.classList.remove('is-warn');
        return;
    }

    const gaps = [];
    if (!status.meetsOrf) gaps.push(`WCPM below ${status.benchmark.orfWcpm}`);
    if (!status.meetsAccuracy) gaps.push(`accuracy below ${status.benchmark.orfAccuracy}%`);
    benchmarkResultOutput.textContent = `Watchlist: ${gaps.join(' and ')}`;
    benchmarkResultOutput.classList.add('is-warn');
    benchmarkResultOutput.classList.remove('is-good');
}

function buildPassageList() {
    const grade = gradeSelect.value;
    const lexile = lexileSelect.value;
    let pool = FLUENCY_PASSAGES.filter(p => p.gradeBand === grade);
    if (lexile !== 'All') {
        pool = pool.filter(p => p.lexileBand === lexile);
    }
    if (pool.length === 0) pool = FLUENCY_PASSAGES;

    passageSelect.innerHTML = pool.map(p => `<option value="${p.id}">${p.title}</option>`).join('');
    currentPassage = pool[0];
    renderPassage();
}

function renderPassage() {
    if (!currentPassage) return;
    titleEl.textContent = currentPassage.title;
    const wc = tokenizePassage(currentPassage.passage).map(normalizeTokenForCount).filter(Boolean).length;
    metaEl.textContent = `Grade ${currentPassage.gradeBand} • Lexile band: ${currentPassage.lexileBand} • Focus: ${currentPassage.focus} • Words: ${wc}`;
    stopCoachListening();
    renderTrackablePassage(currentPassage.passage);
    coachExpectedTokens = getCoachExpectedTokens();
    coachGuideTrail = buildCoachGuideTrail(getCoachTargetText(), 140);
    updateCoachTranscriptView();
    updateCoachComparison();
    drawCoachWaveFrame();
}

function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${m}:${String(s).padStart(2, '0')}`;
}

function updateTimerDisplay() {
    timerDisplay.textContent = formatTime(remainingSeconds);
}

function startTimer() {
    if (timerId) return;
    timerId = setInterval(() => {
        remainingSeconds = Math.max(0, remainingSeconds - 1);
        updateTimerDisplay();
        if (remainingSeconds <= 0) {
            stopTimer();
            feedbackEl.textContent = '⏱️ Time! Enter words read and errors to score.';
        }
    }, 1000);
}

function stopTimer() {
    if (timerId) {
        clearInterval(timerId);
        timerId = null;
    }
}

function resetTimer() {
    stopTimer();
    remainingSeconds = currentDuration;
    updateTimerDisplay();
}

function updateDuration() {
    const minutes = Math.max(1, Number(timerSelect.value) || 1);
    currentDuration = minutes * 60;
    remainingSeconds = currentDuration;
    updateTimerDisplay();
}

function scoreFluency() {
    // If the teacher used the tracker, prefer those values.
    if (trackerStopIndex) {
        syncTrackerToInputs();
    }
    const words = Number(wordsInput.value || 0);
    const errors = Number(errorsInput.value || 0);
    const minutes = currentDuration / 60;
    const correctedWords = Math.max(0, words - errors);
    const orf = correctedWords / minutes;
    const accuracyPct = words > 0 ? (correctedWords / words) * 100 : null;
    scoreOutput.textContent = orf.toFixed(1);
    if (accuracyOutput) {
        accuracyOutput.textContent = Number.isFinite(accuracyPct) ? `${accuracyPct.toFixed(1)}%` : '—';
    }
    renderBenchmarkResult(orf, accuracyPct);

    const goal = Number(goalInput.value || 0);
    if (goal && orf >= goal) {
        progress.coins += 2;
        progress.streak += 1;
        feedbackEl.textContent = '🏅 Goal reached! Coins awarded.';
    } else if (goal) {
        progress.streak = 0;
        feedbackEl.textContent = 'Keep going! Try again to beat the goal.';
    } else {
        feedbackEl.textContent = 'Score saved. Set a goal if you want rewards.';
    }

    const benchmarkStatus = evaluateBenchmarkStatus(orf, accuracyPct);
    if (benchmarkStatus && !benchmarkStatus.meets) {
        feedbackEl.textContent += ` Benchmark assist: target is ${benchmarkStatus.benchmark.orfWcpm}+ WCPM and ${benchmarkStatus.benchmark.orfAccuracy}%+ accuracy.`;
    }
    saveProgress();
    updateHud();

    try {
        const reached = goal ? orf >= goal : null;
        window.DECODE_PLATFORM?.logActivity?.({
            activity: 'fluency',
            label: 'Speed Sprint',
            event: goal ? (reached ? `Goal met: ${orf.toFixed(1)} WCPM` : `Scored: ${orf.toFixed(1)} WCPM`) : `Scored: ${orf.toFixed(1)} WCPM`,
            detail: {
                passageId: currentPassage?.id,
                title: currentPassage?.title,
                gradeBand: currentPassage?.gradeBand,
                lexileBand: currentPassage?.lexileBand,
                focus: currentPassage?.focus,
                goal: goal || null,
                orf: Number(orf.toFixed(1)),
                accuracyPct: Number.isFinite(accuracyPct) ? Number(accuracyPct.toFixed(1)) : null,
                words,
                errors
            }
        });
    } catch (e) {}
}

function init() {
    applyFriendlyNavLabels();
    applyLightTheme();
    applyPlatformGameModeVisibility();
    lineFocusEnabled = readLineFocusPreference();
    loadProgress();
    updateHud();
    buildFilters();
    loadFilters();
    buildBenchmarkControls();
    loadBenchmarkSelection();
    renderBenchmarkSummary();
    buildPassageList();
    updateDuration();
    renderBenchmarkResult(Number.NaN, null);

    gradeSelect.addEventListener('change', () => {
        saveFilters();
        buildPassageList();
    });
    lexileSelect.addEventListener('change', () => {
        saveFilters();
        buildPassageList();
    });
    passageSelect.addEventListener('change', () => {
        const selected = FLUENCY_PASSAGES.find(p => p.id === passageSelect.value);
        if (selected) currentPassage = selected;
        renderPassage();
    });

    timerSelect.addEventListener('change', updateDuration);
    startBtn.addEventListener('click', startTimer);
    pauseBtn.addEventListener('click', stopTimer);
    resetBtn.addEventListener('click', resetTimer);
    scoreBtn.addEventListener('click', scoreFluency);
    benchmarkGradeSelect?.addEventListener('change', () => {
        saveBenchmarkSelection();
        renderBenchmarkSummary();
        renderBenchmarkResult(Number(scoreOutput.textContent || 0), parseFloat(String(accuracyOutput?.textContent || '').replace('%', '')));
    });
    benchmarkWindowSelect?.addEventListener('change', () => {
        saveBenchmarkSelection();
        renderBenchmarkSummary();
        renderBenchmarkResult(Number(scoreOutput.textContent || 0), parseFloat(String(accuracyOutput?.textContent || '').replace('%', '')));
    });
    benchmarkUseGoalBtn?.addEventListener('click', () => {
        applySelectedBenchmarkGoal();
    });
    coachTargetSelect?.addEventListener('change', () => {
        coachExpectedTokens = getCoachExpectedTokens();
        coachGuideTrail = buildCoachGuideTrail(getCoachTargetText(), 140);
        updateCoachComparison();
        drawCoachWaveFrame();
        setCoachStatus(`Coach target set to ${coachTargetSelect.value === 'passage' ? 'whole passage' : 'first sentence'}.`);
    });
    coachStartBtn?.addEventListener('click', () => {
        startCoachListening();
    });
    coachStopBtn?.addEventListener('click', () => {
        stopCoachListening();
    });
    coachClearBtn?.addEventListener('click', () => {
        clearCoach();
    });
    soundRefreshBtn?.addEventListener('click', () => {
        refreshSoundClips();
    });
    soundFilterInput?.addEventListener('input', () => {
        refreshSoundClips();
    });

    window.addEventListener('resize', () => {
        mapWordLines();
        applyLineFocusHighlighting();
        drawCoachWaveFrame();
    });

    window.addEventListener('beforeunload', () => {
        stopCoachListening();
        releaseSoundClipUrls();
    });

    updateCoachButtons();
    updateCoachTranscriptView();
    updateCoachComparison();
    drawCoachWaveFrame();
    refreshSoundClips();
}

init();

function applyPlatformGameModeVisibility() {
    const active = isPlatformGameModeActive();
    const hud = document.querySelector('.fluency-hud');
    if (hud) hud.style.display = active ? 'flex' : 'none';
}

function isPlatformGameModeActive() {
    try {
        const raw = localStorage.getItem('decode_settings');
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        const enabled = !!parsed?.funHud?.enabled;
        const active = !!parsed?.gameMode?.active;
        const hasModes = !!parsed?.gameMode?.teamMode || !!parsed?.gameMode?.timerEnabled || !!parsed?.funHud?.challenge;
        return enabled && active && hasModes;
    } catch (e) {
        return false;
    }
}

function applyFriendlyNavLabels() {
    const map = {
        'Cloze': 'Story Fill',
        'Comprehension': 'Read & Think',
        'Fluency': 'Speed Sprint',
        'Mad Libs': 'Silly Stories'
    };
    document.querySelectorAll('a, button').forEach((el) => {
        const label = (el.textContent || '').trim();
        if (map[label]) {
            el.textContent = map[label];
        }
    });
}
